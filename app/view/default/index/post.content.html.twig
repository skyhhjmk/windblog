<title>{{ page_title|default('WindBlog') }}</title>

{# PJAX SEO 数据容器 - 隐藏但可被 JS 提取 #}
<div id="pjax-seo-data" style="display:none;">
    {% if seo is defined %}
        {% include 'components/seo-meta.html.twig' with {'seo': seo} %}
    {% endif %}
    {% if schema is defined %}
        {% include 'components/structured-data.html.twig' with {'schema': schema} %}
    {% endif %}
</div>

<div id="pjax-container">
    <div class="max-w-full mx-auto">
        {# 面包屑导航 #}
        {% include 'components/breadcrumb.html.twig' %}
        <article class="bg-white rounded-xl shadow-md overflow-hidden no-animation" style="position: relative;">
            <!-- 文章头部 -->
            <div class="p-6 border-b border-gray-100">
                <h1 class="text-3xl font-bold text-gray-800 mb-4">{{ post.title }}</h1>
                <div class="flex items-center text-gray-500 text-sm space-x-4">
                <span class="flex items-center">
                    <i class="far fa-calendar-alt mr-1"></i>
                    {{ post.created_at|local_date('Y-m-d') }}
                </span>
                    <span class="flex items-center">
                    <i class="far fa-user mr-1"></i>
                    <span class="font-medium text-blue-600 hover:text-blue-800 transition-colors cursor-pointer"
                          title="查看作者详情">
                        {{ author }}
                    </span>
                </span>
                    {% if post.primaryAuthor.first().avatar %}
                        <span class="flex items-center">
                    <img src="{{ post.primaryAuthor.first().avatar }}" alt="{{ author }}"
                         class="w-6 h-6 rounded-full mr-1 object-cover" loading="lazy" decoding="async"
                         fetchpriority="low">
                </span>
                    {% endif %}
                </div>
                <div class="mt-3 text-sm text-gray-600 space-x-2 flex flex-wrap px-6">
                    {% if post.categories|length > 0 %}
                        <span class="text-gray-500">分类：</span>
                        {% for c in post.categories %}
                            <a href="/category/{{ c.slug }}.html"
                               class="inline-flex items-center px-2 py-1 bg-blue-50 text-blue-700 rounded hover:bg-blue-100 mr-2">#{{ c.name }}</a>
                        {% endfor %}
                    {% endif %}
                    {% if post.tags|length > 0 %}
                        <span class="text-gray-500 ml-3">标签：</span>
                        {% for t in post.tags %}
                            <a href="/tag/{{ t.slug }}.html"
                               class="inline-flex items-center px-2 py-1 bg-purple-50 text-purple-700 rounded hover:bg-purple-100 mr-2">#{{ t.name }}</a>
                        {% endfor %}
                    {% endif %}
                </div>
            </div>

            <!-- In-Content TOC UI (desktop, inside article) -->
            <style>
                /* Floating action button (absolute in article) */
                #toc-fab {
                    position: absolute;
                    z-index: 5;
                    width: 42px;
                    height: 42px;
                    border-radius: 9999px;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    color: #fff;
                    background: #667eea;
                    box-shadow: none;
                    transition: transform .15s ease, box-shadow .15s ease, opacity .2s ease;
                    opacity: .92;
                }

                #toc-fab:hover {
                    transform: none;
                    box-shadow: none;
                    opacity: 1;
                }

                @media (min-width: 1024px) {
                    #toc-fab {
                        display: flex;
                    }
                }

                /* Drawer (absolute in article) */
                #toc-drawer {
                    position: absolute;
                    z-index: 8;
                    width: 300px;
                    max-height: 60vh;
                    background: #fff;
                    border: 1px solid #e5e7eb;
                    border-radius: 10px;
                    box-shadow: 0 20px 40px rgba(0, 0, 0, .12);
                    display: none;
                    overflow: hidden;
                }

                #toc-drawer.active {
                    display: block;
                    animation: toc-in .20s ease-out both;
                }

                #toc-drawer.closing {
                    animation: toc-out .16s ease-in both;
                }

                @keyframes toc-in {
                    from {
                        opacity: 0;
                        transform: translateX(8px) scale(.98);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(0) scale(1);
                    }
                }

                @keyframes toc-out {
                    from {
                        opacity: 1;
                        transform: translateX(0) scale(1);
                    }
                    to {
                        opacity: 0;
                        transform: translateX(8px) scale(.98);
                    }
                }

                #toc-drawer .toc-header {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    padding: 10px 12px;
                    border-bottom: 1px solid #f3f4f6;
                }

                #toc-drawer .toc-title {
                    font-size: 14px;
                    font-weight: 600;
                    color: #374151;
                }

                #toc-drawer .toc-actions button {
                    color: #667eea;
                    font-size: 12px;
                    padding: 4px 6px;
                    margin-left: 6px;
                    border-radius: 6px;
                    border: 1px solid #e5e7eb;
                    background: #fff;
                }

                #toc-drawer .toc-body {
                    padding: 10px 8px;
                    overflow: auto;
                    max-height: 55vh;
                }

                #toc-drawer .toc-row {
                    position: relative;
                }

                #toc-drawer .toc-item {
                    display: block;
                    color: #374151;
                    border-left: 2px solid transparent;
                    padding: 6px 28px 6px 10px;
                    border-radius: 6px;
                    transition: all .15s ease;
                    white-space: nowrap;
                    text-overflow: ellipsis;
                    overflow: hidden;
                }

                #toc-drawer .toc-item:hover {
                    color: #2563eb;
                    background: #f8fafc;
                }

                #toc-drawer .toc-item.active {
                    color: #1d4ed8;
                    background: #eff6ff;
                    border-left-color: #667eea;
                    font-weight: 600;
                }

                #toc-drawer .toc-indent-0 {
                    padding-left: 8px;
                }

                #toc-drawer .toc-indent-1 {
                    padding-left: 20px;
                }

                #toc-drawer .toc-indent-2 {
                    padding-left: 32px;
                }

                #toc-drawer .toc-indent-3 {
                    padding-left: 44px;
                }

                #toc-drawer .toc-caret {
                    position: absolute;
                    right: 8px;
                    top: 50%;
                    transform: translateY(-50%) rotate(90deg);
                    width: 16px;
                    height: 16px;
                    color: #9ca3af;
                    cursor: pointer;
                    transition: transform .18s ease, color .18s ease;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                }

                #toc-drawer .toc-caret:hover {
                    color: #6b7280;
                }

                #toc-drawer .toc-caret.collapsed {
                    transform: translateY(-50%) rotate(0deg);
                }

                #toc-drawer .toc-children {
                    overflow: hidden;
                    height: auto;
                    transition: height .18s ease;
                }

                /* Rail (absolute in article, no pointer events) */
                #toc-rail {
                    position: absolute;
                    z-index: 4;
                    width: 2px;
                    background: linear-gradient(180deg, rgba(102, 126, 234, .0) 0%, rgba(102, 126, 234, .25) 15%, rgba(102, 126, 234, .35) 50%, rgba(102, 126, 234, .25) 85%, rgba(102, 126, 234, .0) 100%);
                    display: none;
                    pointer-events: none;
                }
            </style>
            <div id="toc-rail" aria-hidden="true"></div>
            <button id="toc-fab" title="文章目录" aria-label="文章目录">
                <i class="fas fa-list-ul"></i>
            </button>
            <aside id="toc-drawer" role="complementary" aria-label="文章目录">
                <div class="toc-header">
                    <div class="toc-title">文章目录</div>
                    <div class="toc-actions">
                        <button id="toc-expand-all" type="button">展开</button>
                        <button id="toc-collapse-all" type="button">折叠</button>
                        <button id="toc-close" type="button">关闭</button>
                    </div>
                </div>
                <div id="toc-list-desktop" class="toc-body"></div>
            </aside>

            <!-- 文章内容 -->
            <div class="p-6">
                {% if post.ai_summary %}
                    <!-- AI摘要块 -->
                    <div
                        class="mb-6 p-4 bg-gradient-to-r from-purple-50 to-blue-50 border-l-4 border-purple-400 rounded-r-lg">
                        <div class="flex items-center mb-2">
                        <span
                            class="inline-flex items-center px-2.5 py-0.5 rounded text-sm font-semibold bg-gradient-to-r from-purple-100 to-blue-100 text-purple-700 border border-purple-200">
                            <i class="fas fa-robot mr-1.5"></i>AI摘要
                        </span>
                        </div>
                        <p class="text-gray-700 leading-relaxed">
                            {{ post.ai_summary }}
                        </p>
                    </div>
                {% endif %}
                <div class="prose max-w-none fade-in-on-scroll no-animation"
                     id="post-container"
                     data-post-id="{{ post.id }}"
                     data-post-slug="{{ post.slug }}">
                    {{ post_html|default('')|raw }}
                </div>
            </div>

            <!-- 文章底部 -->
            <div class="p-6 border-t border-gray-100">
                <div class="flex justify-between items-center">
                    <a href="/"
                       class="inline-flex items-center text-blue-600 hover:text-blue-800 font-medium">
                        <i class="fas fa-arrow-left mr-1"></i>
                        返回首页
                    </a>
                    <div class="text-sm text-gray-500">
                        <i class="far fa-clock mr-1"></i>
                        最后更新: {{ post.updated_at|local_date('Y-m-d') }}
                    </div>
                </div>
            </div>
        </article>


        <!-- 评论区域 -->
        <div class="mt-8 bg-white rounded-xl shadow-md p-6" id="comments-section">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">评论</h2>

            <!-- 评论列表 -->
            <div id="comments-list" class="mb-8">
                <!-- 评论将通过JavaScript动态加载 -->
            </div>

            {% if post.allow_comments %}
                <!-- 评论表单 -->
                <div class="border-t border-gray-200 pt-6">
                    <h3 class="text-lg font-medium text-gray-800 mb-4">发表评论</h3>
                    <form id="comment-form" class="space-y-4">
                        <input type="hidden" name="_token" value="{{ csrf_token|default('') }}">
                        <input type="hidden" id="post-id" name="post_id" value="{{ post.id }}">
                        <input type="hidden" id="parent-id" name="parent_id" value="0">
                        <input type="hidden" id="quoted-text" name="quoted_text" value="">
                        <input type="hidden" id="quoted-comment-id" name="quoted_comment_id" value="0">

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label for="guest_name" class="block text-sm font-medium text-gray-700 mb-1">昵称
                                    *</label>
                                <input type="text" id="guest_name" name="guest_name" required
                                       placeholder="展示在评论区的名称"
                                       class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                            <div>
                                <label for="guest_email" class="block text-sm font-medium text-gray-700 mb-1">邮箱
                                    *</label>
                                <input type="email" id="guest_email" name="guest_email" required
                                       placeholder="仅用于头像与通知，不会公开"
                                       class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                        </div>

                        <div>
                            <label for="content" class="block text-sm font-medium text-gray-700 mb-1">评论内容 *</label>
                            <textarea id="content" name="content" rows="4" required
                                      placeholder="友善发言，理性讨论，禁止广告与人身攻击"
                                      class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
                            <div id="selected-text-quote"
                                 class="mt-2 p-2 bg-gray-100 border-l-4 border-blue-500 text-sm text-gray-600 hidden">
                                <span class="font-medium">引用:</span>
                                <span id="selected-text-content"></span>
                                <button type="button" id="remove-quote" class="ml-2 text-red-500 hover:text-red-700">
                                    &times;
                                </button>
                            </div>
                        </div>

                        <!-- 验证码区域 -->
                        <div id="comment-captcha-wrapper" class="space-y-2"></div>

                        <div>
                            <button type="submit"
                                    class="px-6 py-2 bg-blue-600 text-white font-medium rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors">
                                提交评论
                            </button>
                            <div id="comment-status" class="text-sm text-gray-500 mt-2 hidden"></div>
                        </div>
                    </form>
                </div>
            {% else %}
                <!-- 关闭评论提示 -->
                <div class="border-t border-gray-200 pt-6">
                    <p class="text-gray-500 text-center py-4">该文章已关闭评论功能</p>
                </div>
            {% endif %}
        </div>
    </div>

    <div id="selection-tooltip" class="fixed bg-gray-800 text-white px-3 py-2 rounded text-sm hidden z-50">
        <button id="quote-selection-btn" class="hover:text-blue-300">引用选中内容评论</button>
    </div>
    <script data-pjax-eval="true">
        // 内容缓存（避免重复请求）
        window.__postContentCache = window.__postContentCache || {};
        // 加载状态标记（防止重复请求）
        window.__postLoadingState = window.__postLoadingState || {};
        // 添加一个标志来防止重复初始化
        window.__postRendered = window.__postRendered || false;

        function renderPost() {
            // 检查是否已经渲染过，防止重复执行
            if (window.__postRendered) {
                return;
            }

            const container = document.getElementById('post-container');
            if (!container) {
                console.warn('[Post.content] 容器不存在');
                return;
            }

            try {
                renderContent(container);
                // 标记已渲染
                window.__postRendered = true;
            } catch (error) {
                console.error('[Post.content] 渲染增强失败:', error);
            }
        }

        function renderContent(container) {
            // 代码高亮 & 图表渲染（前端执行，基础 Markdown 已由服务端渲染）
            function loadScript(src, id) {
                return new Promise(function (resolve, reject) {
                    try {
                        if (id && document.getElementById(id)) return resolve(true);
                        if ([...document.getElementsByTagName('script')].some(function (s) {
                            return s.src === src;
                        })) return resolve(true);
                        var s = document.createElement('script');
                        if (id) s.id = id;
                        s.src = src;
                        s.async = true;
                        s.onload = function () {
                            resolve(true);
                        };
                        s.onerror = function () {
                            reject(new Error('load failed: ' + src));
                        };
                        document.head.appendChild(s);
                    } catch (e) {
                        reject(e);
                    }
                });
            }

            function highlightCodes(root) {
                try {
                    if (!window.hljs) return;
                    var skip = /\blanguage-(mermaid|flowchart|echarts|graphviz|plantuml|markmap|abc|smiles|math)\b/;
                    root.querySelectorAll('pre > code').forEach(function (code) {
                        var cls = code.className || '';
                        if (skip.test(cls)) return;
                        window.hljs.highlightElement(code);
                    });
                } catch (_) {
                }
                try {
                    addCopyButtons(root);
                } catch (_) {
                }
            }

            function addCopyButtons(root) {
                var skip = /\blanguage-(mermaid|flowchart|echarts|graphviz|plantuml|markmap|abc|smiles|math)\b/;
                root.querySelectorAll('pre').forEach(function (pre) {
                    if (pre.querySelector('.code-copy-btn')) return;
                    var code = pre.querySelector('code');
                    if (!code) return;
                    var cls = code.className || '';
                    // 普通代码块添加复制按钮，图形类在渲染后另行追加
                    if (skip.test(cls)) return;
                    addCopyButtonToElement(pre, function () {
                        return code.textContent || '';
                    });
                });
            }

            function addCopyButtonToElement(el, getText) {
                try {
                    var btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'code-copy-btn';
                    btn.textContent = '复制';
                    btn.addEventListener('click', function () {
                        var text = '';
                        try {
                            text = (getText && getText()) || '';
                        } catch (_) {
                        }
                        if (!text) return;
                        var done = function () {
                            var old = btn.textContent;
                            btn.textContent = '已复制';
                            btn.classList.add('copied');
                            setTimeout(function () {
                                btn.textContent = old;
                                btn.classList.remove('copied');
                            }, 1200);
                        };
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            navigator.clipboard.writeText(text).then(done).catch(function () {
                                fallbackCopy(text, done);
                            });
                        } else {
                            fallbackCopy(text, done);
                        }
                    });
                    // 确保容器可相对定位
                    var style = window.getComputedStyle(el);
                    if (style.position === 'static') {
                        el.style.position = 'relative';
                    }
                    el.appendChild(btn);
                } catch (_) {
                }
            }

            function fallbackCopy(text, done) {
                try {
                    var ta = document.createElement('textarea');
                    ta.value = text;
                    ta.style.position = 'fixed';
                    ta.style.top = '-9999px';
                    document.body.appendChild(ta);
                    ta.focus();
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    done();
                } catch (_) {
                }
            }

            function parseOptions(raw) {
                var meta = {};
                if (!raw) return {meta: meta, content: ''};
                var lines = (raw || '').split(/\r?\n/);
                if (!lines.length) return {meta: meta, content: raw};
                var first = (lines[0] || '').trim();
                if (/^@option\s+/i.test(first)) {
                    var kvs = first.replace(/^@option\s+/i, '').trim().split(/\s+/);
                    kvs.forEach(function (pair) {
                        var i = pair.indexOf('=');
                        if (i > 0) {
                            var k = pair.slice(0, i).trim();
                            var v = pair.slice(i + 1).trim();
                            meta[k] = v;
                        }
                    });
                    lines.shift();
                }
                return {meta: meta, content: lines.join('\n')};
            }

            function renderMermaid(root) {
                var blocks = root.querySelectorAll('pre > code.language-mermaid');
                if (!blocks.length) return Promise.resolve();
                return loadScript('https://cdn.jsdelivr.net/npm/mermaid@11.9.0/dist/mermaid.min.js', 'mermaid-js').then(function () {
                    blocks.forEach(function (code) {
                        var pre = code.parentElement;
                        var parsed = parseOptions(code.textContent || '');
                        var theme = (parsed.meta.theme || '').toLowerCase();
                        var height = parsed.meta.height || '';
                        var content = parsed.content || '';
                        // 如果指定主题，插入 mermaid init 指令
                        if (theme && content.indexOf('%%{') !== 0) {
                            content = "%%{init: { 'theme': '" + theme + "' }}%%\n" + content;
                        }
                        var div = document.createElement('div');
                        div.className = 'diagram-container mermaid';
                        if (height) {
                            div.style.minHeight = height;
                            div.style.height = height;
                        }
                        div.textContent = content;
                        // 复制按钮（保持原始代码）
                        var raw = code.textContent || '';
                        pre.replaceWith(div);
                        addCopyButtonToElement(div, function () {
                            return raw;
                        });
                    });
                    try {
                        window.mermaid.initialize({startOnLoad: false, securityLevel: 'loose'});
                    } catch (_) {
                    }
                    try {
                        window.mermaid.run({querySelector: '#post-container .mermaid'});
                    } catch (_) {
                    }
                }).catch(function (e) {
                    console.warn(e);
                });
            }

            function renderFlowchart(root) {
                var blocks = root.querySelectorAll('pre > code.language-flowchart');
                if (!blocks.length) return Promise.resolve();
                return loadScript('https://cdn.jsdelivr.net/npm/flowchart.js@1.17.1/dist/flowchart.min.js', 'flowchart-js').then(function () {
                    blocks.forEach(function (code) {
                        try {
                            var pre = code.parentElement;
                            var parsed = parseOptions(code.textContent || '');
                            var height = parsed.meta.height || '';
                            var scale = parsed.meta.scale ? parseFloat(parsed.meta.scale) : undefined;
                            var content = parsed.content || '';
                            var div = document.createElement('div');
                            div.className = 'diagram-container diagram-flowchart';
                            if (height) {
                                div.style.minHeight = height;
                                div.style.height = height;
                            }
                            pre.replaceWith(div);
                            var chart = flowchart.parse(content);
                            var opts = {};
                            if (scale && isFinite(scale)) {
                                opts.scale = scale;
                            }
                            chart.drawSVG(div, opts);
                            // 复制按钮（保持原始代码）
                            var raw = code.textContent || '';
                            addCopyButtonToElement(div, function () {
                                return raw;
                            });
                        } catch (e) {
                            console.warn('flowchart render error', e);
                        }
                    });
                }).catch(function (e) {
                    console.warn(e);
                });
            }

            function renderEcharts(root) {
                var blocks = root.querySelectorAll('pre > code.language-echarts');
                if (!blocks.length) return Promise.resolve();
                return loadScript('https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js', 'echarts-js').then(function () {
                    blocks.forEach(function (code) {
                        try {
                            var pre = code.parentElement;
                            var parsed = parseOptions(code.textContent || '');
                            var height = parsed.meta.height || pre.style.height || '420px';
                            var width = parsed.meta.width || '100%';
                            var theme = parsed.meta.theme || undefined;
                            var renderer = parsed.meta.renderer || undefined; // svg|canvas
                            var dpr = parsed.meta.dpr ? parseFloat(parsed.meta.dpr) : undefined;
                            var background = parsed.meta.background || undefined;
                            var content = parsed.content || '';
                            var div = document.createElement('div');
                            div.className = 'diagram-container diagram-echarts';
                            div.style.width = width;
                            div.style.height = height;
                            pre.replaceWith(div);
                            var opt = {};
                            try {
                                opt = JSON.parse(content);
                            } catch (e) {
                                console.warn('echarts options must be JSON', e);
                            }
                            if (background && !opt.backgroundColor) {
                                opt.backgroundColor = background;
                            }
                            if (window.echarts && opt && typeof opt === 'object') {
                                var initOpts = {};
                                if (renderer) initOpts.renderer = renderer;
                                if (dpr && isFinite(dpr)) initOpts.devicePixelRatio = dpr;
                                var inst = echarts.init(div, theme, initOpts);
                                inst.setOption(opt);
                                // 自适应
                                var ro = new ResizeObserver(function () {
                                    try {
                                        inst.resize();
                                    } catch (_) {
                                    }
                                });
                                ro.observe(div);
                            }
                            // 复制按钮（保持原始代码）
                            var raw = code.textContent || '';
                            addCopyButtonToElement(div, function () {
                                return raw;
                            });
                        } catch (e) {
                            console.warn('echarts render error', e);
                        }
                    });
                }).catch(function (e) {
                    console.warn(e);
                });
            }

            function enhanceClient(root) {
                // 若需要且未加载 highlight.js，则按需加载后再高亮
                const needHighlight = (function () {
                    try {
                        const skip = /\blanguage-(mermaid|flowchart|echarts|graphviz|plantuml|markmap|abc|smiles|math)\b/;
                        const codes = root.querySelectorAll('pre > code');
                        for (let i = 0; i < codes.length; i++) {
                            if (!skip.test(codes[i].className || '')) return true;
                        }
                        return false;
                    } catch (_) {
                        return false;
                    }
                })();

                let start = Promise.resolve();
                if (needHighlight && !window.hljs) {
                    start = loadScript('{{ asset('/assets/js/highlight.min.js') }}', 'hljs-js').catch(function () { /* 忽略加载失败 */
                    });
                }

                start.then(function () {
                    try {
                        highlightCodes(root);
                    } catch (_) {
                    }
                }).then(function () {
                    return renderMermaid(root);
                }).then(function () {
                    return renderFlowchart(root);
                }).then(function () {
                    return renderEcharts(root);
                }).finally(function () {
                    if (window.PjaxProgress && typeof window.PjaxProgress.complete === 'function') {
                        window.PjaxProgress.complete();
                    }
                    if (typeof initComments === 'function') initComments();
                    if (typeof initTextSelection === 'function') initTextSelection();
                    if (typeof buildInPageTOC === 'function') buildInPageTOC();
                });
            }

            // 使用 rAF + setTimeout 让页面先渲染，再执行必要的初始化
            if (window.requestAnimationFrame) {
                requestAnimationFrame(function () {
                    setTimeout(function () {
                        enhanceClient(container);
                    }, 0);
                });
            } else {
                setTimeout(function () {
                    enhanceClient(container);
                }, 0);
            }
        }

        // 目录构建（桌面与移动）
        function buildInPageTOC() {
            try {
                const root = document.getElementById('post-container');
                if (!root) return;
                if (root.dataset.tocBuilt === '1') {
                    return;
                }
                root.dataset.tocBuilt = '1';
                const desktopList = document.getElementById('toc-list-desktop');
                const fab = document.getElementById('toc-fab');
                const drawer = document.getElementById('toc-drawer');
                const btnClose = document.getElementById('toc-close');
                const btnExpandAll = document.getElementById('toc-expand-all');
                const btnCollapseAll = document.getElementById('toc-collapse-all');
                const mobileSection = document.getElementById('mobile-menu-toc-section');
                const mobileList = document.getElementById('mobile-menu-toc');
                if (!desktopList || !fab || !drawer) {
                    return;
                }

                const rail = document.getElementById('toc-rail');

                // Collect H1-H4
                // 仅收集 H2-H4，H1 作为“返回顶部”虚拟项处理
                const nodes = Array.from(root.querySelectorAll('h2, h3, h4'));
                // If no headings, hide UI
                if (nodes.length === 0) {
                    drawer.classList.remove('active');
                    fab.style.display = 'none';
                    if (rail) rail.style.display = 'none';
                    if (mobileSection) mobileSection.classList.add('hidden');
                    return;
                }

                // 有标题时展示按钮与竖线（仅桌面显示）
                function updateTOCVisibility() {
                    const isDesktop = window.innerWidth >= 1024;
                    fab.style.display = isDesktop ? 'flex' : 'none';
                    if (rail) rail.style.display = isDesktop ? 'block' : 'none';
                    if (!isDesktop && drawer) drawer.classList.remove('active');
                }

                updateTOCVisibility();

                // Build numbering
                const counters = [1, 0, 0, 0]; // 预置一个 H1=1（返回顶部），H2/H3/H4 在其下编号
                const items = [];

                function levelIdx(tag) {
                    return parseInt(tag.substring(1), 10) - 1;
                }

                function ensureId(el) {
                    if (!el.id) {
                        const base = (el.textContent || '').trim().replace(/\s+/g, '-').toLowerCase().replace(/[^\w\-\u4e00-\u9fa5]/g, '');
                        let id = base || 'h-' + Math.random().toString(36).slice(2, 7);
                        let i = 2;
                        while (document.getElementById(id)) {
                            id = base + '-' + i++;
                        }
                        el.id = id;
                    }
                    return el.id;
                }

                // Add a virtual top item as H1: 返回顶部
                items.push({id: '__top__', text: '返回顶部', depth: 0, number: '1'});

                nodes.forEach((el) => {
                    const tag = el.tagName.toLowerCase();
                    const idx = Math.min(3, Math.max(0, levelIdx(tag))); // 0..3
                    // update counters
                    counters[idx] += 1;
                    for (let j = idx + 1; j < 4; j++) counters[j] = 0;
                    const number = counters.slice(0, idx + 1).filter(n => n > 0).join('.');
                    const id = ensureId(el);
                    // base depth: treat h1 as depth 0
                    const depth = idx;
                    items.push({id, text: el.textContent || '', depth, number, el});
                });

                function smoothScrollToId(id) {
                    if (id === '__top__') {
                        window.scrollTo({top: 0, behavior: 'smooth'});
                        return;
                    }
                    const target = document.getElementById(id);
                    if (!target) return;
                    const rect = target.getBoundingClientRect();
                    const topOffset = (function () {
                        try {
                            const header = document.querySelector('header');
                            const h = header ? header.getBoundingClientRect().height : 64;
                            return (h || 64) + 12;
                        } catch (_) {
                            return 76;
                        }
                    })();
                    const y = window.scrollY + rect.top - topOffset;
                    window.scrollTo({top: Math.max(0, y), behavior: 'smooth'});
                }

                function buildTree(list) {
                    const nodes = list.map(it => ({...it, children: []}));
                    const roots = [];
                    const stack = [];
                    nodes.forEach(n => {
                        while (stack.length && stack[stack.length - 1].depth >= n.depth) stack.pop();
                        if (!stack.length) roots.push(n); else stack[stack.length - 1].children.push(n);
                        stack.push(n);
                    });
                    return roots;
                }

                function renderTree(container, roots, isMobile) {
                    if (!container) return;
                    container.innerHTML = '';
                    if (isMobile && mobileSection) {
                        if (items.length === 0) mobileSection.classList.add('hidden');
                        else mobileSection.classList.remove('hidden');
                    }
                    const frag = document.createDocumentFragment();

                    function appendNode(parentEl, node) {
                        const row = document.createElement('div');
                        row.className = 'toc-row';
                        const a = document.createElement('a');
                        a.href = node.id === '__top__' ? '#' : ('#' + node.id);
                        a.className = 'toc-item toc-indent-' + Math.min(3, Math.max(0, node.depth));
                        a.textContent = (node.number ? (node.number + ' ') : '') + node.text;
                        a.addEventListener('click', function (e) {
                            e.preventDefault();
                            smoothScrollToId(node.id);
                        });
                        row.appendChild(a);

                        let kidsWrap = null;
                        let caret = null;
                        if (node.children && node.children.length) {
                            caret = document.createElement('span');
                            caret.className = 'toc-caret';
                            caret.innerHTML = '<i class="fas fa-chevron-right"></i>';
                            row.appendChild(caret);

                            kidsWrap = document.createElement('div');
                            kidsWrap.className = 'toc-children';

                            node.children.forEach(ch => appendNode(kidsWrap, ch));

                            // 初始折叠（默认不展开）
                            try {
                                kidsWrap.style.display = 'block';
                                kidsWrap.style.height = '0px';
                                caret.classList.add('collapsed');
                            } catch (_) {
                            }

                            caret.addEventListener('click', function (e) {
                                e.preventDefault();
                                e.stopPropagation();
                                toggleGroup(kidsWrap, caret);
                            });
                        }

                        parentEl.appendChild(row);
                        if (kidsWrap) parentEl.appendChild(kidsWrap);
                    }

                    function toggleGroup(kids, caretEl, expand) {
                        const isCollapsed = caretEl && caretEl.classList.contains('collapsed');
                        const willExpand = (typeof expand === 'boolean') ? expand : isCollapsed;
                        if (willExpand) {
                            caretEl && caretEl.classList.remove('collapsed');
                            // 从 0 -> scrollHeight
                            kids.style.display = 'block';
                            const targetH = kids.scrollHeight;
                            kids.style.height = '0px';
                            requestAnimationFrame(function () {
                                kids.style.height = targetH + 'px';
                            });
                            kids.addEventListener('transitionend', function onEnd() {
                                kids.removeEventListener('transitionend', onEnd);
                                // 动画完成后恢复自适应高度，避免再次强制读取布局
                                kids.style.height = 'auto';
                            });
                        } else {
                            caretEl && caretEl.classList.add('collapsed');
                            // 从当前高度 -> 0
                            const h = kids.scrollHeight;
                            kids.style.height = h + 'px';
                            requestAnimationFrame(function () {
                                kids.style.height = '0px';
                            });
                        }
                    }

                    roots.forEach(n => appendNode(frag, n));
                    container.appendChild(frag);

                    // 暴露全局控制以供“全部展开/全部收缩”使用
                    container.__tocToggleAll = function (expand) {
                        container.querySelectorAll('.toc-children').forEach(function (k) {
                            const caret = k.previousElementSibling && k.previousElementSibling.querySelector('.toc-caret');
                            if (!caret) return;
                            const want = !!expand;
                            const collapsed = caret.classList.contains('collapsed');
                            if (want && collapsed) toggleGroup(k, caret, true);
                            if (!want && !collapsed) toggleGroup(k, caret, false);
                        });
                    }
                    // 展开某个目标节点的整条祖先链
                    container.__tocExpandPath = function (targetId) {
                        try {
                            if (!targetId) return;
                            let anchor = null;
                            const anchors = container.querySelectorAll('a');
                            for (let i = 0; i < anchors.length; i++) {
                                const href = anchors[i].getAttribute('href') || '';
                                if (href.replace(/^#/, '') === targetId) {
                                    anchor = anchors[i];
                                    break;
                                }
                            }
                            if (!anchor) return;
                            let p = anchor.parentElement; // row
                            while (p && p !== container) {
                                if (p.classList && p.classList.contains('toc-children')) {
                                    const caret = p.previousElementSibling && p.previousElementSibling.querySelector('.toc-caret');
                                    if (caret) toggleGroup(p, caret, true);
                                    p = p.parentElement;
                                } else {
                                    p = p.parentElement;
                                }
                            }
                        } catch (_) {
                        }
                    }
                }

                const roots = buildTree(items);
                renderTree(desktopList, roots, false);
                if (mobileList) renderTree(mobileList, roots, true);

                // 默认只展开“当前标题”所在分支
                function getCurrentHeadingId() {
                    if (!nodes || !nodes.length) return null;
                    const topOffset = (function () {
                        try {
                            const header = document.querySelector('header');
                            const h = header ? header.getBoundingClientRect().height : 64;
                            return (h || 64) + 12;
                        } catch (_) {
                            return 76;
                        }
                    })();
                    let bestId = nodes[0] && nodes[0].id ? nodes[0].id : null;
                    let bestScore = Infinity;
                    nodes.forEach(function (n) {
                        if (!n.id) return;
                        const rect = n.getBoundingClientRect();
                        const dist = Math.abs(rect.top - topOffset);
                        if (dist < bestScore) {
                            bestScore = dist;
                            bestId = n.id;
                        }
                    });
                    return bestId;
                }

                const currentId = getCurrentHeadingId();
                if (desktopList && desktopList.__tocToggleAll) desktopList.__tocToggleAll(false);
                if (desktopList && desktopList.__tocExpandPath && currentId) desktopList.__tocExpandPath(currentId);
                if (mobileList && mobileList.__tocToggleAll) mobileList.__tocToggleAll(false);
                if (mobileList && mobileList.__tocExpandPath && currentId) mobileList.__tocExpandPath(currentId);

                // 使已标记为“展开”的分组在抽屉可见时同步到实际高度
                function syncExpandedHeights(container) {
                    try {
                        if (!container) return;
                        container.querySelectorAll('.toc-children').forEach(function (k) {
                            const caret = k.previousElementSibling && k.previousElementSibling.querySelector('.toc-caret');
                            if (caret && !caret.classList.contains('collapsed')) {
                                k.style.display = 'block';
                                const h = k.scrollHeight;
                                if (h > 0) k.style.height = h + 'px';
                            }
                        });
                    } catch (_) {
                    }
                }

                // 定位：使 FAB / 抽屉 / 竖线 贴合内容列右侧（侧边栏左侧）
                function positionTOCUI() {
                    try {
                        const article = root.closest('article');
                        if (!article) {
                            return;
                        }
                        article.style.position = article.style.position || 'relative';
                        const headerDiv = article.querySelector('.p-6.border-b.border-gray-100');
                        const contentWrapper = root.closest('.p-6');
                        if (!headerDiv || !contentWrapper) {
                            return;
                        }
                        const artRect = article.getBoundingClientRect();
                        const headRect = headerDiv.getBoundingClientRect();
                        const contRect = contentWrapper.getBoundingClientRect();
                        const rightInside = contRect.right - artRect.left; // inside-article X (content right)
                        const anchorTop = (headRect.bottom - artRect.top);  // inside-article Y (header bottom)
                        const artW = Math.max(0, article.clientWidth || (artRect.right - artRect.left));

                        // 文档坐标（用于粘滞定位与边界裁切）
                        const articleDocTop = window.scrollY + artRect.top;
                        const contentBottomDoc = window.scrollY + contRect.bottom;
                        const headBottomDoc = window.scrollY + headRect.bottom;

                        // FAB（水平绝对，垂直“粘滞”且限制在内容上下界内）
                        let fabLeftVal = null, fabTopVal = null;
                        if (fab) {
                            const fabW = fab.offsetWidth || 42;
                            const fabH = fab.offsetHeight || 42;
                            let left = Math.round(rightInside - fabW - 6);
                            // clamp within article
                            left = Math.max(6, Math.min(left, artW - fabW - 6));
                            fab.style.left = left + 'px';
                            fabLeftVal = fab.style.left;
                            fab.style.right = 'auto';

                            // 记录初始视口内的目标偏移（首次定位时），让按钮在视口中“保持”这个相对位置
                            if (typeof window.__tocFabViewportOffset !== 'number') {
                                window.__tocFabViewportOffset = Math.max(8, headRect.bottom + 8); // 距视口顶部偏移
                            }
                            const desiredDocY = window.scrollY + window.__tocFabViewportOffset;
                            const minDocY = articleDocTop + anchorTop + 8;
                            let maxDocY = contentBottomDoc - fabH - 8;
                            if (maxDocY < minDocY) maxDocY = minDocY;
                            const docY = Math.max(minDocY, Math.min(desiredDocY, maxDocY));
                            const topInside = docY - articleDocTop;
                            fab.style.top = Math.round(topInside) + 'px';
                            fabTopVal = fab.style.top;
                        }
                        // Rail height constrained to content block only（随文章滚动，非粘滞）
                        let railLeftVal = null, railTopVal = null, railHVal = null;
                        if (rail) {
                            let left = Math.round(rightInside - 4);
                            left = Math.max(2, Math.min(left, artW - 4));
                            rail.style.left = left + 'px';
                            railLeftVal = rail.style.left;
                            rail.style.right = 'auto';
                            rail.style.top = Math.round(anchorTop) + 'px';
                            railTopVal = rail.style.top;
                            const railH = Math.max(0, Math.round((contRect.bottom - artRect.top) - anchorTop));
                            rail.style.height = railH + 'px';
                            railHVal = rail.style.height;
                        }
                        // Drawer（与 FAB 垂直对齐，贴右）
                        let drawerLeftVal = null, drawerTopVal = null;
                        if (drawer) {
                            const dw = drawer.offsetWidth || 300;
                            let left = Math.round(rightInside - dw - 8);
                            left = Math.max(8, Math.min(left, artW - dw - 8));
                            drawer.style.left = left + 'px';
                            drawerLeftVal = drawer.style.left;
                            drawer.style.right = 'auto';
                            // 若有 FAB，抽屉与其对齐；否则退化到 header 下
                            if (fab && fab.style.top) {
                                drawer.style.top = (parseInt(fab.style.top, 10) + 4) + 'px';
                            } else {
                                drawer.style.top = Math.round(anchorTop + 12) + 'px';
                            }
                            drawerTopVal = drawer.style.top;
                        }
                    } catch (_) {
                    }
                }

                positionTOCUI();
                // 页面加载后可能有图片延迟撑高，稍后再定位一次
                setTimeout(positionTOCUI, 300);
                window.addEventListener('resize', positionTOCUI);
                // 同步不同视口尺寸下的可见性
                window.addEventListener('resize', updateTOCVisibility);
                // 追求性能：避免在滚动过程中频繁测量布局，仅在尺寸变化或抽屉打开时定位
                // 如需开启随滚动跟随，请恢复下面代码
                // let __tocRaf = 0;
                // window.addEventListener('scroll', function () {
                //     if (__tocRaf) return;
                //     __tocRaf = requestAnimationFrame(function () {
                //         __tocRaf = 0;
                //         positionTOCUI();
                //     });
                // }, {passive: true});

                // Scroll spy
                try {
                    const map = new Map();
                    // map id->anchor in desktop list
                    Array.from(desktopList.querySelectorAll('a')).forEach(a => {
                        const href = a.getAttribute('href') || '';
                        const id = href.replace(/^#/, '');
                        map.set(id, a);
                    });
                    const io = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            const id = entry.target.id;
                            const a = map.get(id);
                            if (!a) return;
                            if (entry.isIntersecting) {
                                // clear
                                map.forEach(node => node.classList.remove('active'));
                                a.classList.add('active');
                            }
                        });
                    }, {rootMargin: '0px 0px -70% 0px', threshold: [0, 1]});
                    nodes.forEach(n => {
                        if (n.id) io.observe(n);
                    });
                } catch (_) {
                }

                // Drawer toggles（防重复绑定 + 关闭动画）
                function closeDrawerAnimated() {
                    if (!drawer.classList.contains('active')) return;
                    drawer.classList.add('closing');
                    const onEnd = function () {
                        drawer.removeEventListener('animationend', onEnd);
                        drawer.classList.remove('closing');
                        drawer.classList.remove('active');
                    };
                    drawer.addEventListener('animationend', onEnd);
                }

                if (!fab.dataset.bound) {
                    fab.dataset.bound = '1';
                    fab.addEventListener('click', () => {
                        if (!drawer.classList.contains('active')) {
                            try {
                                positionTOCUI();
                            } catch (_) {
                            }
                            drawer.classList.remove('closing');
                            drawer.classList.add('active');
                            // 等抽屉可见后再同步展开分组的高度（两帧确保布局完成）
                            requestAnimationFrame(function () {
                                requestAnimationFrame(function () {
                                    try {
                                        syncExpandedHeights(desktopList);
                                    } catch (_) {
                                    }
                                });
                            });
                        } else {
                            closeDrawerAnimated();
                        }
                    });
                }
                if (btnClose && !btnClose.dataset.bound) {
                    btnClose.dataset.bound = '1';
                    btnClose.addEventListener('click', () => closeDrawerAnimated());
                }

                // Collapse/expand all（带动画）
                if (btnCollapseAll && !btnCollapseAll.dataset.bound) {
                    btnCollapseAll.dataset.bound = '1';
                    btnCollapseAll.addEventListener('click', () => {
                        if (desktopList && desktopList.__tocToggleAll) desktopList.__tocToggleAll(false);
                    });
                }
                if (btnExpandAll && !btnExpandAll.dataset.bound) {
                    btnExpandAll.dataset.bound = '1';
                    btnExpandAll.addEventListener('click', () => {
                        if (desktopList && desktopList.__tocToggleAll) desktopList.__tocToggleAll(true);
                    });
                }
            } catch (_) {
            }
        }

        // 监听 page:ready 和 DOMContentLoaded 事件
        document.addEventListener('DOMContentLoaded', function () {
            // 检查是否在文章页
            if (!document.getElementById('post-container')) {
                return;
            }
            window.__rpTry = 0;
            // 重置渲染状态
            window.__postRendered = false;
            renderPost();
        });

        document.addEventListener('page:ready', function () {
            // 检查是否在文章页
            if (!document.getElementById('post-container')) {
                return;
            }
            window.__rpTry = 0;
            // 重置渲染状态
            window.__postRendered = false;
            renderPost();
        });

        // 立即执行一次（用于 PJAX 加载）
        (function () {
            // 检查是否在文章页
            const container = document.getElementById('post-container');
            if (!container) {
                return;
            }


            // 确保DOM已加载完成
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function () {
                    window.__rpTry = 0;
                    // 重置渲染状态
                    window.__postRendered = false;
                    injectSidebar();
                    renderPost();
                });
            } else {
                // 使用setTimeout确保在PJAX完全加载后再执行
                setTimeout(function () {
                    window.__rpTry = 0;
                    // 重置渲染状态
                    window.__postRendered = false;
                    injectSidebar();
                    renderPost();
                }, 0);
            }

            function injectSidebar() {
                var t = document.getElementById('pjax-sidebar-html');
                var c = document.getElementById('sidebar-container');
                if (!t || !c) return;
                if (window.PJAX || window.jQuery) {
                    try {
                        document.dispatchEvent(new CustomEvent('pjax:sidebarReady'));
                    } catch (_) {
                    }
                } else {
                    c.innerHTML = t.innerHTML || '';
                }
            }
        })();

        // 初始化评论功能
        function initComments() {
            // 渲染评论验证码
            (async function () {
                try {
                    const res = await fetch('/captcha/config');
                    const json = await res.json();
                    const c = json && json.data ? json.data : {enabled: false};
                    const wrap = document.getElementById('comment-captcha-wrapper');
                    if (!wrap || !c.enabled) return;
                    if (c.type === 'turnstile' && c.sitekey) {
                        const div = document.createElement('div');
                        div.className = 'cf-turnstile';
                        div.setAttribute('data-sitekey', c.sitekey);
                        wrap.appendChild(div);
                        const s = document.createElement('script');
                        s.src = 'https://challenges.cloudflare.com/turnstile/v0/api.js';
                        s.async = true;
                        s.defer = true;
                        document.body.appendChild(s);
                    } else if (c.type === 'image') {
                        const box = document.createElement('div');
                        box.className = 'flex items-center space-x-2';
                        box.innerHTML = `
                            <input name="captcha" placeholder="请输入验证码" class="mt-1 flex-1 appearance-none rounded-md px-3 py-2 border border-gray-300 text-gray-900 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" />
                            <img id="commentCaptchaImg" src="/captcha/image?ts=${Date.now()}" alt="验证码" class="h-10 w-28 cursor-pointer border border-gray-300 rounded" title="点击刷新" />
                        `;
                        wrap.appendChild(box);
                        box.querySelector('#commentCaptchaImg').addEventListener('click', function () {
                            this.src = '/captcha/image?ts=' + Date.now();
                        });
                    }
                } catch (_) {
                }
            })();
            const postId = {{ post.id }};
            const allowComments = {{ post.allow_comments|default(true) ? 'true' : 'false' }};

            // 始终加载已有评论（无论是否允许评论）
            loadComments(postId);

            // 如果不允许评论，不初始化表单事件
            if (!allowComments) {
                return;
            }

            // 读取cookie填充昵称与邮箱
            try {
                const cn = getCookie('cmt_name');
                const ce = getCookie('cmt_email');
                if (cn) {
                    const n = document.getElementById('guest_name');
                    if (n) n.value = cn;
                }
                if (ce) {
                    const e = document.getElementById('guest_email');
                    if (e) e.value = ce;
                }
            } catch (_) {
            }

            // 恢复上次未通过/待审核的本地评论（cookie）
            try {
                const lastRaw = getCookie('cmt_last_comment');
                if (lastRaw) {
                    const last = JSON.parse(lastRaw);
                    if (last && String(last.post_id) === String({{ post.id }})) {
                        appendOwnComment({
                            id: last.id,
                            guest_name: last.guest_name,
                            guest_email: last.guest_email,
                            content: last.content
                        }, last.status === 'pending');
                        if (last.status === 'pending') {
                            setTimeout(function () {
                                fetch('/comment/status/' + last.id)
                                    .then(r => r.json())
                                    .then(s => {
                                        if (s && s.code === 0) {
                                            const res = s.data;
                                            if (res.status === 'spam' || res.ai_moderation_result === 'rejected' || res.ai_moderation_result === 'spam') {
                                                markOwnCommentRejected(last.id, res.ai_moderation_reason || '已拒绝');
                                                setCookie('cmt_last_comment', JSON.stringify({
                                                    ...last,
                                                    status: 'rejected'
                                                }), 1);
                                            } else if (res.status === 'approved') {
                                                // 审核通过则清除此条本地记录
                                                setCookie('cmt_last_comment', '', -1);
                                            }
                                        }
                                    }).catch(() => {
                                });
                            }, 15000);
                        } else if (last.status === 'rejected') {
                            // 已拒绝则标红
                            markOwnCommentRejected(last.id, '已拒绝');
                        }
                    }
                }
            } catch (_) {
            }

            // 提交评论表单
            const commentForm = document.getElementById('comment-form');
            if (commentForm) {
                if (!commentForm.dataset.bound) {
                    commentForm.dataset.bound = '1';
                    commentForm.addEventListener('submit', function (e) {
                        e.preventDefault();
                        submitComment(postId);
                    });
                }

                // 移除回车提交功能，使回车正常换行
                const contentTextarea = document.getElementById('content');
                if (contentTextarea && !contentTextarea.dataset.bound) {
                    contentTextarea.dataset.bound = '1';
                    contentTextarea.addEventListener('keydown', function (e) {
                        // 不做任何阻止，让回车正常换行
                    });
                }
            }

            // 移除引用按钮
            const removeQuoteBtn = document.getElementById('remove-quote');
            if (removeQuoteBtn) {
                removeQuoteBtn.addEventListener('click', function () {
                    const selectedTextQuote = document.getElementById('selected-text-quote');
                    const parentId = document.getElementById('parent-id');
                    const quotedText = document.getElementById('quoted-text');
                    const quotedCommentId = document.getElementById('quoted-comment-id');

                    if (selectedTextQuote) selectedTextQuote.classList.add('hidden');
                    if (parentId) parentId.value = '0';
                    if (quotedText) quotedText.value = '';
                    if (quotedCommentId) quotedCommentId.value = '0';
                });
            }
        }

        // 加载评论
        function loadComments(postId) {
            const commentsList = document.getElementById('comments-list');
            if (!commentsList) {
                console.warn('[Post.content] 评论列表容器不存在');
                return;
            }

            fetch('/comment/list/' + postId)
                .then(response => response.json())
                .then(data => {
                    if (data.code === 0) {
                        renderComments(commentsList, data.data);
                    } else {
                        commentsList.innerHTML = '<p class="text-gray-500">加载评论失败</p>';
                    }
                })
                .catch(error => {
                    console.error('[Post.content] 评论加载失败:', error);
                    if (commentsList) {
                        commentsList.innerHTML = '<p class="text-gray-500">加载评论失败</p>';
                    }
                });
        }

        // 渲染评论
        function renderComments(container, comments) {
            if (!container) {
                console.warn('[Post.content] 评论容器不存在');
                return;
            }

            // Handle nested structure where comments is an object with a comments field
            const commentsList = Array.isArray(comments) ? comments : (comments.comments || []);

            if (!commentsList || commentsList.length === 0) {
                container.innerHTML = '<p class="text-gray-500">暂无评论</p>';
                return;
            }

            let commentsHtml = '';
            commentsList.forEach(comment => {
                // 处理评论内容
                let content = comment.content.replace(/\n/g, '<br>');

                // 如果有结构化的引用数据，显示引用块
                let quoteHtml = '';
                if (comment.quote && comment.quote.content) {
                    const quoteType = comment.quote.type || 'post';
                    const quoteAuthor = comment.quote.author ? `@${comment.quote.author}` : '文章内容';
                    quoteHtml = `
                    <div class="border-l-4 border-blue-500 pl-3 py-2 mb-3 bg-blue-50 rounded">
                        <div class="text-xs text-gray-500 mb-1">${quoteAuthor}:</div>
                        <div class="text-sm text-gray-700">${comment.quote.content}</div>
                    </div>
                `;
                }

                // 生成Gravatar头像URL
                const avatarUrl = comment.guest_email ? getGravatarUrl(comment.guest_email, 80, 'identicon') : '';
                const avatarHtml = avatarUrl
                    ? `<img src="${avatarUrl}" alt="${comment.guest_name}" class="w-10 h-10 rounded-full border border-gray-200" loading="lazy">`
                    : `<div class="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center">
                    <span class="text-gray-600 font-medium">${comment.guest_name.charAt(0)}</span>
                </div>`;

                commentsHtml += `
                <div class="mb-6 border-b border-gray-100 pb-6" data-comment-id="${comment.id}">
                    <div class="flex items-start">
                        <div class="flex-shrink-0 mr-3">
                            ${avatarHtml}
                        </div>
                        <div class="flex-1">
                            <div class="flex items-center">
                                <h4 class="text-sm font-medium text-gray-900">${comment.guest_name}</h4>
                                <span class="mx-2 text-gray-300">•</span>
                                <span class="text-xs text-gray-500">${formatDate(comment.created_at)}</span>
                            </div>
                            <div class="mt-2 text-gray-700">
                                ${quoteHtml}
                                ${content}
                            </div>
                            <div class="mt-2">
                                <button class="text-xs text-blue-600 hover:text-blue-800 reply-btn"
                                        data-comment-id="${comment.id}"
                                        data-comment-name="${comment.guest_name}">
                                    回复
                                </button>
                            </div>

                            <!-- 回复列表 -->
                            ${comment.replies && comment.replies.length > 0 ? `
                                <div class="mt-4 ml-6 space-y-4">
                                    ${comment.replies.map(reply => {
                    // 处理回复内容
                    let replyContent = reply.content.replace(/\n/g, '<br>');

                    // 如果有结构化的引用数据，显示引用块
                    let replyQuoteHtml = '';
                    if (reply.quote && reply.quote.content) {
                        const quoteAuthor = reply.quote.author ? `@${reply.quote.author}` : '文章内容';
                        replyQuoteHtml = `
                                                <div class="border-l-4 border-blue-500 pl-2 py-1 mb-2 bg-blue-50 rounded">
                                                    <div class="text-xs text-gray-500 mb-1">${quoteAuthor}:</div>
                                                    <div class="text-xs text-gray-700">${reply.quote.content}</div>
                                                </div>
                                            `;
                    }

                    // 生成回复者头像
                    const replyAvatarUrl = reply.guest_email ? getGravatarUrl(reply.guest_email, 64, 'identicon') : '';
                    const replyAvatarHtml = replyAvatarUrl
                        ? `<img src="${replyAvatarUrl}" alt="${reply.guest_name}" class="w-8 h-8 rounded-full border border-gray-200" loading="lazy">`
                        : `<div class="w-8 h-8 rounded-full bg-gray-100 flex items-center justify-center">
                                                <span class="text-gray-500 text-xs">${reply.guest_name.charAt(0)}</span>
                                            </div>`;

                    return `
                                            <div class="flex items-start" data-comment-id="${reply.id}">
                                                <div class="flex-shrink-0 mr-3">
                                                    ${replyAvatarHtml}
                                                </div>
                                                <div class="flex-1">
                                                    <div class="flex items-center">
                                                        <h5 class="text-xs font-medium text-gray-900">${reply.guest_name}</h5>
                                                        <span class="mx-1 text-gray-300">•</span>
                                                        <span class="text-xs text-gray-500">${formatDate(reply.created_at)}</span>
                                                    </div>
                                                    <div class="mt-1 text-sm text-gray-700">
                                                        ${replyQuoteHtml}
                                                        ${replyContent}
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                }).join('')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
            });

            container.innerHTML = commentsHtml;

            // 绑定回复按钮事件
            document.querySelectorAll('.reply-btn').forEach(button => {
                button.addEventListener('click', function () {
                    const commentId = this.getAttribute('data-comment-id');
                    const commentName = this.getAttribute('data-comment-name');
                    replyToComment(commentId, commentName);
                });
            });
        }

        // 回复评论
        function replyToComment(commentId, commentName) {
            document.getElementById('parent-id').value = commentId;
            document.getElementById('selected-text-content').textContent = `${commentName}: `;
            document.getElementById('selected-text-quote').classList.remove('hidden');
            document.getElementById('quoted-comment-id').value = commentId;

            // 滚动到评论表单
            document.getElementById('comment-form').scrollIntoView({behavior: 'smooth'});
        }

        // 提交评论（带防抖与加载动画）
        function submitComment(postId) {
            const form = document.getElementById('comment-form');
            if (!form || form.dataset.submitting === '1') {
                return; // 防止重复提交
            }
            form.dataset.submitting = '1';

            const btn = form.querySelector('button[type="submit"]');
            const statusEl = document.getElementById('comment-status');
            const formData = new FormData(form);

            // 按钮进入加载态
            if (btn) {
                if (!btn.dataset.label) btn.dataset.label = btn.innerHTML;
                btn.disabled = true;
                btn.innerHTML = '<svg class="animate-spin -ml-1 mr-2 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path></svg>提交中…';
            }
            if (statusEl) {
                statusEl.classList.remove('hidden');
                statusEl.textContent = '正在提交评论…';
            }

            fetch('/comment/submit/' + postId, {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.code === 0) {
                        // 写入cookie，便于下次自动填充
                        try {
                            const nameVal = (document.getElementById('guest_name') || {}).value;
                            const emailVal = (document.getElementById('guest_email') || {}).value;
                            if (nameVal) setCookie('cmt_name', nameVal, 180);
                            if (emailVal) setCookie('cmt_email', emailVal, 180);
                        } catch (_) {
                        }

                        // 仅清空正文与引用，不清空昵称/邮箱
                        const textarea = document.getElementById('content');
                        if (textarea) textarea.value = '';
                        const quoteBox = document.getElementById('selected-text-quote');
                        if (quoteBox) quoteBox.classList.add('hidden');
                        const pid = document.getElementById('parent-id');
                        const qtxt = document.getElementById('quoted-text');
                        const qid = document.getElementById('quoted-comment-id');
                        if (pid) pid.value = '0';
                        if (qtxt) qtxt.value = '';
                        if (qid) qid.value = '0';

                        // 状态提示：自动审核中或成功 + 将本条评论以“仅用户可见”追加到列表
                        var requiresModeration = !!(data.data && data.data.requires_moderation);
                        var newComment = (data.data && data.data.comment) ? data.data.comment : null;
                        if (statusEl) {
                            statusEl.textContent = requiresModeration ? '评论已提交，正在自动审核…' : '评论提交成功';
                        }
                        if (newComment) {
                            try {
                                appendOwnComment(newComment, requiresModeration);
                            } catch (_) {
                            }
                            // 将本条评论存入cookie，避免服务器刷新后因为审核快速而不可见
                            try {
                                setCookie('cmt_last_comment', JSON.stringify({
                                    id: newComment.id,
                                    post_id: {{ post.id }},
                                    guest_name: newComment.guest_name,
                                    guest_email: newComment.guest_email,
                                    content: newComment.content,
                                    status: requiresModeration ? 'pending' : 'submitted',
                                    ts: Date.now()
                                }), 1);
                            } catch (_) {
                            }

                            // 15秒后查询状态，若被拒绝则标红/更新cookie
                            setTimeout(function () {
                                fetch('/comment/status/' + newComment.id)
                                    .then(r => r.json())
                                    .then(s => {
                                        if (s && s.code === 0) {
                                            const res = s.data;
                                            if (res.status === 'spam' || res.ai_moderation_result === 'rejected' || res.ai_moderation_result === 'spam') {
                                                try {
                                                    markOwnCommentRejected(newComment.id, res.ai_moderation_reason || '已拒绝');
                                                } catch (_) {
                                                }
                                                try {
                                                    const lastRaw = getCookie('cmt_last_comment');
                                                    if (lastRaw) {
                                                        const last = JSON.parse(lastRaw);
                                                        if (last && String(last.id) === String(newComment.id)) {
                                                            setCookie('cmt_last_comment', JSON.stringify({
                                                                ...last,
                                                                status: 'rejected'
                                                            }), 1);
                                                        }
                                                    }
                                                } catch (_) {
                                                }
                                                if (statusEl) {
                                                    statusEl.classList.remove('hidden');
                                                    statusEl.textContent = '审核未通过：' + (res.ai_moderation_reason || '已拒绝');
                                                }
                                            } else if (res.status === 'approved') {
                                                // 审核通过则清除此条本地记录并标绿
                                                try {
                                                    markOwnCommentApproved(newComment.id, res.ai_moderation_reason || '审核通过');
                                                } catch (_) {
                                                }
                                                if (statusEl) {
                                                    statusEl.classList.remove('hidden');
                                                    statusEl.textContent = '审核通过：' + (res.ai_moderation_reason || '已通过');
                                                }
                                                setCookie('cmt_last_comment', '', -1);
                                            }
                                        }
                                    }).catch(() => {
                                });
                            }, 15000);
                        }

                        // 不再刷新评论列表，避免审核很快导致用户自己的评论被“消失”的错觉
                    } else {
                        if (statusEl) {
                            statusEl.textContent = '提交失败：' + (data.msg || '请稍后再试');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error submitting comment:', error);
                    if (statusEl) {
                        statusEl.textContent = '评论提交失败，请稍后再试';
                    }
                })
                .finally(() => {
                    // 恢复按钮
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = btn.dataset.label || '提交评论';
                    }
                    setTimeout(function () {
                        if (statusEl) statusEl.classList.add('hidden');
                    }, 3000);
                    form.dataset.submitting = '0';
                });
        }

        // 仅提交者可见的评论渲染
        function appendOwnComment(comment, pending) {
            const list = document.getElementById('comments-list');
            if (!list) return;
            const container = document.createElement('div');
            container.className = 'mb-6 border border-dashed border-yellow-300 rounded-md p-4 bg-yellow-50';
            container.id = 'own-comment-' + comment.id;
            container.setAttribute('data-own', '1');

            const avatarUrl = comment.guest_email ? getGravatarUrl(comment.guest_email, 80, 'identicon') : '';
            const avatarHtml = avatarUrl
                ? `<img src="${avatarUrl}" alt="${comment.guest_name}" class="w-10 h-10 rounded-full border border-gray-200" loading="lazy">`
                : `<div class="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center">
                    <span class="text-gray-600 font-medium">${(comment.guest_name || 'U').charAt(0)}</span>
               </div>`;
            const quoteHtml = '';
            const contentHtml = (comment.content || '').replace(/\n/g, '<br>');
            const badge = pending
                ? `<span id="own-comment-badge-${comment.id}" class="ml-2 text-xs px-2 py-1 rounded bg-yellow-200 text-yellow-900">自动审核中（仅自己可见）</span>`
                : `<span id="own-comment-badge-${comment.id}" class="ml-2 text-xs px-2 py-1 rounded bg-green-100 text-green-700">已提交（仅自己可见）</span>`;

            container.innerHTML = `
            <div class="flex items-start">
                <div class="flex-shrink-0 mr-3">${avatarHtml}</div>
                <div class="flex-1">
                    <div class="flex items-center">
                        <h4 class="text-sm font-medium text-gray-900">${comment.guest_name || '我'}</h4>
                        ${badge}
                        <span class="mx-2 text-gray-300">•</span>
                        <span class="text-xs text-gray-500">刚刚</span>
                    </div>
                    <div class="mt-2 text-gray-700">${quoteHtml}${contentHtml}</div>
                </div>
            </div>
        `;
            // 追加到列表首位
            list.prepend(container);
        }

        function markOwnCommentRejected(id, reason) {
            const el = document.getElementById('own-comment-' + id);
            if (!el) return;
            el.className = 'mb-6 border border-red-400 rounded-md p-4 bg-red-50';
            const badge = document.getElementById('own-comment-badge-' + id);
            if (badge) {
                badge.textContent = '审核未通过';
                badge.className = 'ml-2 text-xs px-2 py-1 rounded bg-red-200 text-red-900';
            }
            const badgetxt = '已被拒绝：' + reason;
            const label = document.createElement('div');
            label.className = 'mt-2 text-sm text-red-700';
            label.textContent = badgetxt;
            el.appendChild(label);
        }

        function markOwnCommentApproved(id, reason) {
            const el = document.getElementById('own-comment-' + id);
            if (!el) return;
            el.className = 'mb-6 border border-green-400 rounded-md p-4 bg-green-50';
            const badge = document.getElementById('own-comment-badge-' + id);
            if (badge) {
                badge.textContent = '审核通过';
                badge.className = 'ml-2 text-xs px-2 py-1 rounded bg-green-200 text-green-900';
            }
            const ok = document.createElement('div');
            ok.className = 'mt-2 text-sm text-green-700';
            ok.textContent = '审核通过：' + (reason || '已通过');
            el.appendChild(ok);
        }

        // 简易 Cookie 工具
        function setCookie(name, value, days) {
            const d = new Date();
            d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = name + '=' + encodeURIComponent(value) + ';expires=' + d.toUTCString() + ';path=/';
        }

        function getCookie(name) {
            const match = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'));
            return match ? decodeURIComponent(match[1]) : '';
        }

        // 格式化日期
        function formatDate(dateString) {
            // 处理带微秒的 ISO 8601 格式 (例如: 2025-10-16T04:02:30.000000Z)
            // 移除微秒部分，只保留到秒: 2025-10-16T04:02:30Z
            const normalizedDateString = dateString.replace(/(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})(\.\d+)?(Z?)/, '$1$3');

            // 正确处理：保留Z，让JavaScript自动转换为UTC时间
            // 数据库存储的是UTC时间，new Date()会自动转换为本地时间
            const date = new Date(normalizedDateString);
            const now = new Date();
            const diff = now - date;

            // 处理负数时间差（评论时间在未来）或无效日期
            if (isNaN(diff) || diff < 0) {
                console.warn('[formatDate] 时间差异常（负数或NaN），返回格式化日期');
                return date.getFullYear() + '年' + (date.getMonth() + 1) + '月' + date.getDate() + '日';
            }

            if (diff < 60000) { // 1分钟内
                return '刚刚';
            } else if (diff < 3600000) { // 1小时内
                const result = Math.floor(diff / 60000) + '分钟前';
                return result;
            } else if (diff < 86400000) { // 1天内
                const result = Math.floor(diff / 3600000) + '小时前';
                return result;
            } else {
                const result = date.getFullYear() + '年' + (date.getMonth() + 1) + '月' + date.getDate() + '日';
                return result;
            }
        }

        // 初始化划词评论功能
        function initTextSelection() {
            const postContainer = document.getElementById('post-container');
            const tooltip = document.getElementById('selection-tooltip');
            const quoteBtn = document.getElementById('quote-selection-btn');

            // 检查核心元素是否存在
            if (!postContainer || !tooltip || !quoteBtn) {
                console.warn('[Post.content] 划词评论所需的核心元素不存在');
                return;
            }

            // 变量用于跟踪是否显示了提示框
            let tooltipVisible = false;
            let currentSelection = '';
            let tooltipShownAt = 0; // 记录提示框显示时间，用于防抖首次点击

            // 监听鼠标释放事件（使用选区矩形定位）
            postContainer.addEventListener('mouseup', function () {
                setTimeout(showTooltipForSelection, 0);
            });

            // 监听选区变化，动态更新或隐藏提示框
            document.addEventListener('selectionchange', function () {
                setTimeout(showTooltipForSelection, 0);
            });

            // 滚动或窗口尺寸变化时隐藏提示框，避免位置错乱
            window.addEventListener('scroll', function () {
                tooltip.classList.add('hidden');
                tooltipVisible = false;
            }, {passive: true});
            window.addEventListener('resize', function () {
                tooltip.classList.add('hidden');
                tooltipVisible = false;
            });

            function showTooltipForSelection() {
                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0 || selection.isCollapsed) {
                    tooltip.classList.add('hidden');
                    tooltipVisible = false;
                    return;
                }
                const selectedText = selection.toString().trim();
                if (!selectedText || selectedText.length <= 1) {
                    tooltip.classList.add('hidden');
                    tooltipVisible = false;
                    return;
                }
                let inContainer = false;
                try {
                    const range = selection.getRangeAt(0);
                    const anc = range.commonAncestorContainer;
                    const node = (anc && anc.nodeType === 1) ? anc : (anc ? anc.parentNode : null);
                    if (node && postContainer.contains(node)) inContainer = true;
                    if (!inContainer) {
                        const an = selection.anchorNode;
                        const fn = selection.focusNode;
                        if ((an && postContainer.contains(an)) || (fn && postContainer.contains(fn))) inContainer = true;
                    }
                } catch (_) {
                }
                if (!inContainer) {
                    tooltip.classList.add('hidden');
                    tooltipVisible = false;
                    return;
                }
                currentSelection = selectedText;
                showTooltipFromSelection();
                tooltipVisible = true;
            }

            // 点击页面其他地方隐藏提示框
            document.addEventListener('mousedown', function (e) {
                // 只有当点击的不是提示框内的元素时才隐藏
                if (tooltip && !tooltip.contains(e.target)) {
                    tooltip.classList.add('hidden');
                    tooltipVisible = false;
                }
            });

            // 引用选中文本按钮点击事件
            quoteBtn.addEventListener('click', function (e) {
                e.stopPropagation(); // 阻止事件冒泡
                // 防止在显示后立即因残留点击而误触发
                if (Date.now() - tooltipShownAt < 300) {
                    return;
                }

                if (currentSelection) {
                    // 获取必需元素
                    const selectedTextQuote = document.getElementById('selected-text-quote');
                    const selectedTextContent = document.getElementById('selected-text-content');
                    const quotedText = document.getElementById('quoted-text');
                    const parentId = document.getElementById('parent-id');
                    const commentForm = document.getElementById('comment-form');
                    const textarea = document.getElementById('content');

                    // 显示引用
                    if (selectedTextContent && selectedTextQuote && quotedText) {
                        selectedTextContent.textContent = currentSelection;
                        selectedTextQuote.classList.remove('hidden');
                        quotedText.value = currentSelection;
                    } else {
                        console.warn('[Post.content] 引用相关元素不存在，跳过引用设置');
                    }

                    // 清除之前的父评论ID
                    if (parentId) {
                        parentId.value = '0';
                    }

                    // 设置quoted_comment_id为0表示引用文章内容而非评论
                    const quotedCommentId = document.getElementById('quoted-comment-id');
                    if (quotedCommentId) {
                        quotedCommentId.value = '0';
                    }

                    // 滚动到评论表单
                    if (commentForm) {
                        commentForm.scrollIntoView({behavior: 'smooth'});
                        // 聚焦到评论框
                        if (textarea) {
                            setTimeout(() => textarea.focus(), 500);
                        }
                    }
                }

                // 隐藏提示框
                tooltip.classList.add('hidden');
                tooltipVisible = false;
            });
        }

        // 显示提示框
        function showTooltipFromSelection() {
            const tooltip = document.getElementById('selection-tooltip');
            if (!tooltip) return;
            const sel = window.getSelection();
            if (!sel || sel.rangeCount === 0) return;
            const range = sel.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // 先显示以便测量尺寸（不闪烁）
            tooltip.style.visibility = 'hidden';
            tooltip.classList.remove('hidden');
            const tooltipWidth = tooltip.offsetWidth || 120;
            const tooltipHeight = tooltip.offsetHeight || 30;

            // 计算基于 viewport 的位置（fixed 定位不需要 pageOffset）
            let finalX = (rect.left + rect.width / 2) - (tooltipWidth / 2);
            let finalY = rect.top - tooltipHeight - 8; // 优先显示在上方
            if (finalY < 8) {
                finalY = rect.bottom + 8; // 空间不足时显示在下方
            }
            // 视口内约束
            finalX = Math.max(8, Math.min(finalX, viewportWidth - tooltipWidth - 8));
            finalY = Math.max(8, Math.min(finalY, viewportHeight - tooltipHeight - 8));

            // 应用位置
            tooltip.style.position = 'fixed';
            tooltip.style.left = Math.round(finalX) + 'px';
            tooltip.style.top = Math.round(finalY) + 'px';
            tooltip.style.zIndex = '9999';
            tooltip.style.visibility = '';

            // 记录显示时间并短暂禁用点击，避免鼠标抬起后的残余 click 命中按钮
            tooltipShownAt = Date.now();
            tooltip.style.pointerEvents = 'none';
            setTimeout(() => {
                tooltip.style.pointerEvents = 'auto';
            }, 250);
        }
    </script>
</div>
